Kim Douglas
Computing IV 
91.204 Section 201
Due 2/11/2015

In my program, an LFSR object has both a string representation and a vector representation. Originally, I translated the string bits to a vector of integers (once, in the constructor), and used this vector to do the step() and generate() functions. It seemed easier to do those operations with integers than with a string. It wasn't until later, when I found out that the overloaded << stream had to be in string form, that I added a string representation, maintained in the _seedStr member variable and updated with vectorToString(), called with each call to step(). In retrospect, were I to do this again, I would probably not bother with creating a vector.

Anyway, in my vector representation, the back of the vector corresponds to the 0th bit. So, internally, the _subtractedTap member variable is equivalent to the tap parameter subtracted from the length of the vector. I could find my XOR'd bit in a single line by using the bitwise ^ operator on _subtractedTap and the leftmost bit. Then I could shift all my bits to the left by reassigning the indices of my vector and setting its rightmost element (the back element) to the XOR'd bit. All this was accomplished in about 5 lines of code, which is why I liked the vector representation.

I added 3 additional BOOST tests - one for a very short seed string (3 bits), one for a very long seed string (32 bits), and one that handles incorrect strings (just for fun). 

The first two blocks test an edge case, the rightmost bit. I did not feel the need to test a bit somewhere in the middle, because that was already done in the provided test. Each of these blocks creates two instances of the LFSR - one, to test a couple of the step() functions individually, and another to test the generate() function. Each instance is actually the same string of bits with the same tap position - but I had to use two different instances since the tests modify them. The two LFSR objects do not need to have the same bit string or tap position, but having the same bit sequence displayed from the step() tests helps the programmer to understand what is happening in the generate() test. Both of those new tests succeed.

I was having fun with this assignment so I tried my hand at exception handling with BOOST - I realize my implementation probably isn't how you're supposed to do it, but I figured I'd give it a shot. I have a function called stringToVector() that translates the string's ASCII characters to integers, and checks that only 1 and 0 characters exist in the string. If there's a rogue character, it throws an exception identifying the character and its index in the string, and returns a 1. If none of this happens and all is kosher, it returns a 0. My BOOST test requires that stringToVector() returns a 0.
 